import { itm_context, imm_on, h } from './itm_context.jsy'
import { itm_import_attrs , import_at } from './itm_import.jsy'
import { itm_dynamic } from './itm_dynamic.jsy'


export class ItmCore extends HTMLElement ::
  _ctx_ = itm_context

  async connectedCallback() ::
    this.abort_ctl?.abort('conn')
    let abort_ctl = this.abort_ctl = new AbortController()
    try ::
      let ctx = await @ this.ctx ??= this._itm_init(abort_ctl)
      if ! abort_ctl.signal.aborted ::
        await this._itm_conn?.(ctx, abort_ctl)
        await ctx?.wc_connect?.(abort_ctl)
    catch err ::
      abort_ctl.abort('err:'+err)
      throw err

  async _itm_init(abort_ctl) ::
    let ctx = this._ctx_.with({wc: this})
    ctx = await this._itm_ctx?.(ctx, abort_ctl) ?? ctx

    for let [attr, import_url] of itm_import_attrs(this) ::
      let module = await ctx.import_at(import_url)
      ctx = await this._itm_extend(ctx, module) ?? ctx

    return this.ctx = ctx

  _itm_extend(ctx, module) :: return module.itermuse?.(ctx)
  // _itm_ctx(ctx) ::

  disconnectedCallback() ::
    let ctx = this.ctx
    this.abort_ctl?.abort('dis')
    this.ctx = null
    return ctx?.wc_disconnect?.()

  itm_reload() ::
    if ! this.isConnected ::
      return false

    let pxy = h.del() // use a proxy dom element
    this.replaceWith(pxy) // invoke disconnected
    pxy.replaceWith(this) // invoke connected
    return true


export class ItmView extends ItmCore ::
  _ctx_ = itm_dynamic


export class ItmRoot extends ItmCore ::
  async _itm_ctx(ctx, {signal}) ::
    ctx.viewmap = this.viewmap ??= new Map()
    ctx.stg = await this.stg

    imm_on @ this.parentNode,
      @{} 
        itm_stg(evt) :: evt.detail.stg = ctx.stg
        itm_mime(evt) :: evt.detail.push(ctx.viewmap)
      {signal}
      
  async _itm_init(abort_ctl) ::
    let ctx = await super._itm_init(abort_ctl)
    ctx.cfg_impulse(1)
    return ctx

