import { itm_context, itm_root } from './itm_context.jsy'
import { itm_dynamic } from './itm_dynamic.jsy'


export class ItmCore extends HTMLElement ::
  _ctx_ = itm_context

  async connectedCallback() ::
    this.abort_ctl?.abort('conn')
    this.signal = (this.abort_ctl = new AbortController()).signal
    try ::
      let ctx = this.ctx = await @ this.ctx ??= this._itm_init()
      if ! this.signal.aborted ::
        await this._itm_conn?.(ctx)
        await ctx?.wc_connect?.()
    catch err ::
      this.abort_ctl.abort('err:'+err)
      throw err

  async _itm_init() ::
    let ctx = await this._ctx_.with({wc: this})
    ctx = await this._itm_import(ctx)
    return ctx

  async _itm_import(ctx) ::
    for let [attr, import_url] of _itm_import_attrs(this) ::
      let module = await ctx.import_at(import_url)
      if module ::
        ctx = await this._itm_extend(ctx, module) ?? ctx
    return ctx
  _itm_extend(ctx, module) :: return module.itermuse?.(ctx)


  disconnectedCallback() ::
    let ctx = this.ctx
    this.abort_ctl.abort('dis')
    this.ctx = null
    return ctx?.wc_disconnect?.()

  itm_reload() ::
    if this.isConnected ::
      // use a proxy dom element
      let pxy = this.ownerDocument.createElement('del')
      this.replaceWith(pxy) // invoke disconnected
      pxy.replaceWith(this) // invoke connected
      return true
    return false

  itm_dbg() ::
    console.log @ 'itm_root has stg?', this.ctx.itm_disco('itm_stg',[])
    console.log @ 'itm_root has mime?', this.ctx.itm_disco('itm_mime',[])



/////////////////////////////////////////
// ItmView provides an extended context prototype for DOM rendering

export class ItmView extends ItmCore ::
  _ctx_ = itm_dynamic

  render(...args) ::
    this.textContent = ''
    this.append(... args)

/////////////////////////////////////////
// ItmRoot provides storage and mimeview roots

export class ItmRoot extends ItmCore ::
  _ctx_ = itm_root

  async _itm_init() ::
    this.stg = await this.stg
    let ctx = this._ctx_.with @:
      wc: this, stg: this.stg, mimeview: this.mimeview

    ctx = await this._itm_import(ctx)
    return ctx
      
  async _itm_conn(ctx) ::
    let el_parent = this.parentNode
    let evt_opt = @{} signal: this.signal, passive: true
    el_parent.addEventListener @ 'itm_stg',
      evt => :: evt.detail.push(ctx.stg)
      evt_opt

    el_parent.addEventListener @ 'itm_mime',
      evt => :: evt.detail.push(ctx.mimeview)
      evt_opt

    this.dispatchEvent @
      new CustomEvent('itm_root', {bubbles: true})



/////////////////////////////////////////
// Import via element attributes

const _rx_dep = /^dep(?:-\w+)?/, _rx_init = /^init(?:-\w+)?/
function * _itm_import_attrs(elem, test, test_init) ::
  for let attr of elem.getAttributeNames() ::
    let init = _rx_init.test(attr)
    if init || _rx_dep.test(attr) ::
      let val = elem.getAttribute(attr)
      if init :: elem.removeAttribute(attr)
      yield [attr, val]

