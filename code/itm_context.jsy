export const itm_base = @{}
  __proto__: null

  with(kw) :: return {__proto__: this, ...kw}

  itm_disco(evt, detail) ::
    this.wc.dispatchEvent @ 
      new CustomEvent(evt, { detail, composed: true, bubbles: true })
    return detail

  async itm_disco_update() ::
    let wc=this.wc, signal=wc.signal, el_root=wc.ownerDocument.documentElement
    await new Promise @ on_update =>
      el_root.addEventListener @ 'itm_root', on_update,
          { signal, once: true, passive:true }
    return ! signal.aborted


  async find_stg() ::
    let stg = this.stg, wc=this.wc, signal=wc.signal
    while ! stg ::
      stg = this.itm_disco('itm_stg',[]).find(Boolean)
      if stg :: return this.stg = stg

      if ! await this.itm_disco_update() :: return
    return stg

  async kbc_fetch(kbckey, mime) ::
    kbckey = kbckey.pathname ?? kbckey
    let stg = this.stg ?? await this.find_stg()

    let ab = await stg.kbc_fetch(kbckey, {signal: this.wc.signal})
    ab &&= new Blob([ab], {type: mime}) 
    return ab


  async import_at(ref, opt) ::
    ref &&= new URL(ref, opt?.base_url ?? globalThis.location)

    if 'kbc:' === ref?.protocol ::
      let blob = await this.kbc_fetch(ref.pathname, 'text/javascript')
      ref = blob ? URL.createObjectURL(blob) : null

    if ref ::
      let module = await import(/* @vite-ignore */ ref, {... opt})
      return module



export const itm_root = @{}
  __proto__: itm_base
  base: itm_base



export const itm_context = @{}
  __proto__: itm_base
  base: itm_base

  async load_content() ::
    return this.content ??= await this.fetch_content @
      this.wc.getAttribute('k'), this.wc.getAttribute('mime')

  async fetch_content(ref, mime, fetch_opt) ::
    ref &&= new URL(ref, 'kbc:')

    if 'kbc:' === ref?.protocol ::
      return await this.kbc_fetch(ref.pathname, mime)

    if ref ::
      let resp = await fetch @ ref,
        @{} signal: this.wc.signal, ...fetch_opt
      return await resp

