
export const itm_base = @{}
  __proto__: null

  with(kw) :: return {__proto__: this, ...kw}
  set(kw) :: return Object.assign(this, kw)


  itm_disco(evt, list, fn=Boolean) ::
    let detail = list ?? []
    this.wc.dispatchEvent @
      new CustomEvent(evt, { detail, composed: true, bubbles: true })
    return list ? detail.filter(fn) : detail.find(fn)

  async itm_disco_update() ::
    let wc=this.wc, signal=wc.signal, el_root=wc.ownerDocument.documentElement
    await new Promise @ on_update =>
      el_root.addEventListener @ 'itm_root', on_update,
          { signal, once: true, passive:true }
    return ! signal.aborted


  async find_stg() ::
    let stg = this.stg, wc=this.wc, signal=wc.signal
    while ! stg ::
      stg = this.itm_disco('itm_find_stg')
      if stg :: return this.stg = stg

      if ! await this.itm_disco_update() :: return
    return stg

  async kbc_fetch(kbckey, mime) ::
    kbckey = kbckey.pathname ?? kbckey
    let stg = this.stg ?? await this.find_stg()

    let ab = await stg.kbc_fetch(kbckey, {signal: this.wc.signal})
    ab &&= new Blob([ab], {type: mime})
    return ab


  async import_at(ref, opt) ::
    ref &&= new URL(ref, opt?.base_url ?? globalThis.location)

    if 'kbc:' === ref?.protocol ::
      let blob = await this.kbc_fetch(ref.pathname, 'text/javascript')
      ref = blob ? URL.createObjectURL(blob) : null

    if ref ::
      let module = await import(/* @vite-ignore */ ref, {... opt})
      return module


  imtiny(el, attr, ...z) ::
    if ! el.nodeType :: el = this.wc.ownerDocument.createElement(el)
    Object.assign(el, attr).append(...z)
    return el

  async view_pre_text(content) ::
    content = await (await content)?.text()
    return this.imtiny('pre', {class: 'itm-pre'}, ''+content)


export const itm_root = @{}
  __proto__: itm_base
  base: itm_base

  async mime_when(type, preconditions, view_for_mime) ::
    this.mimeview.set.call // validate mimeview is available

    for let c of [preconditions].flat(2) ::
      if c?.trim :: c = customElements.whenDefined(c)
      c = await c

    this.mimeview.set(type, view_for_mime)
    return true


export const itm_context = @{}
  __proto__: itm_base
  base: itm_base

  async load_content() ::
    return this.content ??= await this.fetch_content @
      this.wc.getAttribute('k'), this.wc.getAttribute('mime')

  async fetch_content(ref, mime, fetch_opt) ::
    ref &&= new URL(ref, 'kbc:')

    if 'kbc:' === ref?.protocol ::
      return await this.kbc_fetch(ref.pathname, mime)

    if ref ::
      let resp = await fetch @ ref,
        @{} signal: this.wc.signal, ...fetch_opt
      return await resp

