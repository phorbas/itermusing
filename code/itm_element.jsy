import { ItmDisco } from './itm_disco.jsy'
import { imm_set, h, _itm_ctx_ } from './itm_utils.jsy'

const 
    _view_dbg = msg => (_, kw) =>
      document.createComment(` ${msg}: ${kw.mime} ${kw.key} `)
  , _view_absent = _view_dbg('content absent')
  , _view_missing = _view_dbg('view missing')


export class ItmContent extends HTMLElement ::
  constructor() :: super();
    this.attachShadow({mode: 'open'}).append(h.slot())

  get key() :: return this.getAttribute('k')
  get mime() :: return this.getAttribute('mime')
  get dep() :: return this.getAttribute('dep')

  async connectedCallback() ::
    for await let _itm_ of ItmDisco.discover(this) ::
      if 0 === _itm_.stores.length || 0 === _itm_.viewmaps.length ::
        continue

      let {mime, key, dep} = this
      let content = _itm_.content_at(key, mime)
      dep &&= await _itm_.import_at(dep)
      let view_ctx = _itm_ctx_.with @: mime, content, key, _itm_, elem:this
      let view_fn = this._find_view(_itm_, dep, view_ctx)
      ; [content, view_fn] = await Promise.all([content, view_fn])

      imm_set(this, await view_fn(content, view_ctx))

  async _find_view(_itm_, dep, view_ctx) ::
    let view
    if dep ::
      view = dep.view_for ? dep
        : await dep.itm_find_view?.(view_ctx)

    view ??= _itm_.find_mime(view_ctx.mime)

    if null == await view_ctx.content ::
      return view?.view_absent ?? _itm_.find_mime('absent') ?? _view_absent

    view = view?.view_for ?? view
    view ??= _itm_.find_mime('missing') ?? _view_missing
    return view

